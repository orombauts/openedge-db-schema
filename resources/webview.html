<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Content-Security-Policy" content="default-src 'none'; style-src {{cspSource}} 'unsafe-inline'; font-src {{cspSource}}; script-src 'nonce-{{nonce}}';">
    <link rel="stylesheet" href="{{codiconUri}}">
    <title>OpenEdge ABL Schema</title>
    <style>
        html, body {
            height: 100%;
            margin: 0;
            padding: 0;
            overflow: hidden;
        }

        body {
            display: flex;
            flex-direction: column;
            font-family: var(--vscode-font-family);
            font-size: var(--vscode-font-size);
            color: var(--vscode-foreground);
        }

        .search-container {
            flex-shrink: 0;
            padding: 8px;
            background: var(--vscode-sideBar-background);
            border-bottom: 1px solid var(--vscode-panel-border);
        }

        .toolbar {
            display: flex;
            justify-content: flex-end;
            gap: 4px;
            margin-bottom: 12px;
            padding-bottom: 12px;
            border-bottom: 1px solid var(--vscode-panel-border);
        }

        .toolbar button {
            padding: 4px 8px;
        }

        .search-box {
            display: flex;
            gap: 4px;
            margin-bottom: 6px;
        }

        input[type="text"] {
            flex: 1;
            padding: 4px 8px;
            background: var(--vscode-input-background);
            color: var(--vscode-input-foreground);
            border: 1px solid var(--vscode-input-border);
            outline: none;
        }

        input[type="text"]:focus {
            border-color: var(--vscode-focusBorder);
        }

        button {
            padding: 4px 8px;
            background: var(--vscode-button-background);
            color: var(--vscode-button-foreground);
            border: none;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        button:hover {
            background: var(--vscode-button-hoverBackground);
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .options {
            display: flex;
            gap: 4px;
            font-size: 12px;
        }

        .toggle-btn {
            padding: 4px 8px;
            background: var(--vscode-button-secondaryBackground);
            color: var(--vscode-button-secondaryForeground);
            border: 1px solid var(--vscode-button-border);
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .toggle-btn:hover {
            background: var(--vscode-button-secondaryHoverBackground);
        }

        .toggle-btn.active {
            background: var(--vscode-button-background);
            color: var(--vscode-button-foreground);
            border-color: var(--vscode-focusBorder);
        }

        .tree-container {
            flex: 1;
            padding: 8px;
            overflow: auto;
        }

        .tree-item {
            padding: 2px 0;
            cursor: pointer;
        }

        .tree-item:hover {
            background: var(--vscode-list-hoverBackground);
        }

        .tree-item-content {
            display: flex;
            align-items: center;
            padding: 2px 4px;
        }

        .tree-item.selected {
            background: var(--vscode-list-activeSelectionBackground);
            color: var(--vscode-list-activeSelectionForeground);
        }

        .expand-icon {
            width: 16px;
            height: 16px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            margin-right: 2px;
            -webkit-user-select: none;
            user-select: none;
        }

        .icon {
            margin: 0 4px;
            font-size: 16px;
            display: inline-flex;
            align-items: center;
            -webkit-user-select: none;
            user-select: none;
        }

        .label {
            flex: 1;
        }

        .description {
            color: var(--vscode-descriptionForeground);
            margin-left: 8px;
            font-size: 0.9em;
        }

        .children {
            margin-left: 16px;
        }

        .hidden {
            display: none;
        }

        .no-data {
            padding: 16px;
            text-align: center;
            color: var(--vscode-descriptionForeground);
        }

        .loading {
            padding: 16px;
            text-align: center;
            color: var(--vscode-descriptionForeground);
        }

        .loading::before {
            content: "";
            display: inline-block;
            width: 16px;
            height: 16px;
            border: 2px solid var(--vscode-descriptionForeground);
            border-top-color: transparent;
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
            margin-right: 8px;
            vertical-align: middle;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .context-menu {
            position: fixed;
            background: var(--vscode-menu-background);
            border: 1px solid var(--vscode-menu-border);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
            z-index: 1000;
            min-width: 150px;
        }

        .context-menu-item {
            padding: 4px 12px;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .context-menu-item:hover {
            background: var(--vscode-menu-selectionBackground);
            color: var(--vscode-menu-selectionForeground);
        }

        .search-highlight {
            background: var(--vscode-editor-findMatchHighlightBackground, #ea5c0055);
            color: inherit;
            border-radius: 2px;
        }
    </style>
</head>
<body>
    <div class="search-container">
        <div class="toolbar">
            <button id="refreshBtn" title="Refresh Schema" class="codicon codicon-refresh"></button>
            <button id="saveBtn" title="Dump Schema to File" class="codicon codicon-save"></button>
            <button id="sortAlphabeticallyBtn" class="toggle-btn codicon codicon-sort-precedence" title="Sort fields and indexes alphabetically"></button>
        </div>
        <div class="search-box">
            <input type="text" id="searchInput" placeholder="Search schema...">
            <button id="searchBtn" title="Search" class="codicon codicon-search"></button>
            <button id="clearBtn" title="Clear search" class="codicon codicon-close"></button>
        </div>
        <div class="options">
            <button id="caseSensitiveBtn" class="toggle-btn codicon codicon-case-sensitive" title="Case-sensitive search"></button>
            <button id="useWildcardBtn" class="toggle-btn codicon codicon-regex" title="Wildcard search (* and ?)"></button>
        </div>
    </div>
    <div class="tree-container" id="treeContainer">
        <div class="no-data">No schema data loaded. Click refresh to load schema.</div>
    </div>

    <script nonce="{{nonce}}">
        const vscode = acquireVsCodeApi();
        let schemaData = null;
        let originalFieldsOrder = new Map(); // Store original order of fields per table
        let originalIndexesOrder = new Map(); // Store original order of indexes per table
        let expandedNodes = new Set(); // Track which nodes are expanded
        let searchPattern = '';
        let caseSensitive = false;
        let useWildcard = false;
        let sortAlphabetically = false;
        let contextMenu = null;
        let contextMenuTarget = null;
        let mouseDownPos = { x: 0, y: 0 };

        // Restore state if available
        const previousState = vscode.getState();
        if (previousState) {
            sortAlphabetically = previousState.sortAlphabetically || false;
            if (sortAlphabetically) {
                document.getElementById('sortAlphabeticallyBtn').classList.add('active');
            }
        }

        // Listen for messages from extension
        window.addEventListener('message', event => {
            const message = event.data;
            switch (message.type) {
                case 'loading':
                    showLoading();
                    break;
                case 'schemaData':
                    schemaData = message.data;
                    // Store original field and index order for each table
                    if (schemaData && schemaData.databases) {
                        schemaData.databases.forEach(db => {
                            db.tables.forEach(table => {
                                const key = `${db.name}.${table.name}`;
                                originalFieldsOrder.set(key, [...table.fields]);
                                originalIndexesOrder.set(key, [...table.indexes]);
                            });
                        });
                    }
                    renderTree();
                    break;
            }
        });

        // Toolbar button handlers
        document.getElementById('refreshBtn').addEventListener('click', () => {
            vscode.postMessage({ type: 'refresh' });
        });

        document.getElementById('saveBtn').addEventListener('click', () => {
            vscode.postMessage({ type: 'save' });
        });

        document.getElementById('sortAlphabeticallyBtn').addEventListener('click', (e) => {
            sortAlphabetically = !sortAlphabetically;
            e.target.classList.toggle('active', sortAlphabetically);
            vscode.setState({ sortAlphabetically });
            captureExpandedState();
            renderTree();
            restoreExpandedState();
        });

        // Search functionality
        document.getElementById('searchInput').addEventListener('input', (e) => {
            searchPattern = e.target.value;
            renderTree();
        });

        document.getElementById('searchBtn').addEventListener('click', () => {
            searchPattern = document.getElementById('searchInput').value;
            renderTree();
        });

        document.getElementById('clearBtn').addEventListener('click', () => {
            document.getElementById('searchInput').value = '';
            searchPattern = '';
            renderTree();
        });

        document.getElementById('caseSensitiveBtn').addEventListener('click', (e) => {
            caseSensitive = !caseSensitive;
            e.target.classList.toggle('active', caseSensitive);
            renderTree();
        });

        document.getElementById('useWildcardBtn').addEventListener('click', (e) => {
            useWildcard = !useWildcard;
            e.target.classList.toggle('active', useWildcard);
            renderTree();
        });

        document.getElementById('searchInput').addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                searchPattern = e.target.value;
                renderTree();
            }
        });

        // Suppress the native context menu entirely so VS Code's chrome never intercepts it
        document.addEventListener('contextmenu', (e) => {
            e.preventDefault();
            e.stopPropagation();
        }, true /* capture phase */);

        // Detect right-click on mousedown (before VS Code can steal focus)
        // Also track position to distinguish plain clicks from drag-selections
        document.addEventListener('mousedown', (e) => {
            mouseDownPos = { x: e.clientX, y: e.clientY };

            if (e.button === 2) {
                const target = e.target.closest('.tree-item');
                if (target && !target.classList.contains('tree-item--container')) {
                    e.preventDefault();
                    showContextMenu(e.clientX, e.clientY, target);
                } else {
                    hideContextMenu();
                }
            }
        });

        // Hide context menu when clicking outside it (left-click)
        document.addEventListener('pointerdown', (e) => {
            if (e.button !== 2 && contextMenu && !contextMenu.contains(e.target)) {
                hideContextMenu();
            }
        });

        function showContextMenu(x, y, target) {
            hideContextMenu();
            contextMenuTarget = target;

            contextMenu = document.createElement('div');
            contextMenu.className = 'context-menu';
            contextMenu.style.left = x + 'px';
            contextMenu.style.top = y + 'px';

            // "Copy name" is available on every node
            const copyNameItem = document.createElement('div');
            copyNameItem.className = 'context-menu-item';
            copyNameItem.innerHTML = '<span class="codicon codicon-copy"></span>Copy name';
            copyNameItem.addEventListener('click', () => {
                copyNodeName(contextMenuTarget);
                hideContextMenu();
            });
            contextMenu.appendChild(copyNameItem);

            // "Copy JSON" only for database and table nodes
            const content = contextMenuTarget.querySelector('.tree-item-content');
            const hasTableIcon = content && content.querySelector('.codicon-table');
            const hasDatabaseIcon = content && content.querySelector('.codicon-database');
            if (hasTableIcon || hasDatabaseIcon) {
                const copyJsonItem = document.createElement('div');
                copyJsonItem.className = 'context-menu-item';
                copyJsonItem.innerHTML = '<span class="codicon codicon-json"></span>Copy JSON';
                copyJsonItem.addEventListener('click', () => {
                    copyNodeToClipboard(contextMenuTarget);
                    hideContextMenu();
                });
                contextMenu.appendChild(copyJsonItem);
            }

            document.body.appendChild(contextMenu);
        }

        function copyNodeName(node) {
            const content = node.querySelector('.tree-item-content');
            const label = content && content.querySelector('.label');
            const name = label ? label.textContent.trim() : '';
            vscode.postMessage({ type: 'copyName', name });
        }

        function hideContextMenu() {
            if (contextMenu) {
                contextMenu.remove();
                contextMenu = null;
                contextMenuTarget = null;
            }
        }

        function copyNodeToClipboard(node) {
            const content = node.querySelector('.tree-item-content');
            const label = content.querySelector('.label');
            const nodeName = label ? label.textContent : '';

            const hasTableIcon = content && content.querySelector('.codicon-table');
            const hasDatabaseIcon = content && content.querySelector('.codicon-database');

            if (hasDatabaseIcon) {
                // Copy database
                vscode.postMessage({
                    type: 'copyNode',
                    nodeType: 'database',
                    databaseName: nodeName
                });
            } else if (hasTableIcon) {
                // Copy table - need to find parent database
                let dbNode = node.parentElement;
                while (dbNode && !dbNode.classList.contains('tree-item')) {
                    dbNode = dbNode.parentElement;
                }

                if (dbNode) {
                    const dbContent = dbNode.querySelector('.tree-item-content');
                    const dbLabel = dbContent.querySelector('.label');
                    const databaseName = dbLabel ? dbLabel.textContent : '';

                    vscode.postMessage({
                        type: 'copyNode',
                        nodeType: 'table',
                        databaseName: databaseName,
                        tableName: nodeName
                    });
                }
            }
        }

        function getNodeText(node, indent) {
            let text = '';
            const indentStr = '  '.repeat(indent);

            const content = node.querySelector('.tree-item-content');
            if (content) {
                const label = content.querySelector('.label');
                const description = content.querySelector('.description');

                text = indentStr + (label ? label.textContent : '');
                if (description && description.textContent) {
                    text += ' - ' + description.textContent;
                }
                text += '\n';
            }

            // Add all children (regardless of whether they're hidden or not)
            const childrenDiv = node.querySelector(':scope > .children');
            if (childrenDiv) {
                const childItems = childrenDiv.querySelectorAll(':scope > .tree-item');
                childItems.forEach(child => {
                    text += getNodeText(child, indent + 1);
                });
            }

            return text;
        }

        function matchesSearch(text) {
            if (!searchPattern) return true;

            let pattern = searchPattern;
            let target = text;

            if (!caseSensitive) {
                pattern = pattern.toLowerCase();
                target = target.toLowerCase();
            }

            if (useWildcard) {
                // Escape special regex characters except * and ?
                let regexPattern = pattern;
                const specialChars = ['.', '+', '^', '$', '{', '}', '(', ')', '|', '[', ']', '\\'];
                specialChars.forEach(char => {
                    regexPattern = regexPattern.split(char).join('\\' + char);
                });
                regexPattern = regexPattern.replace(/\*/g, '.*').replace(/\?/g, '.');
                const regex = new RegExp('^' + regexPattern + '$', caseSensitive ? '' : 'i');
                return regex.test(target);
            }

            return target.includes(pattern);
        }

        function captureExpandedState() {
            expandedNodes.clear();
            const treeItems = document.querySelectorAll('.tree-item');
            treeItems.forEach(item => {
                const childrenDiv = item.querySelector(':scope > .children');
                if (childrenDiv && !childrenDiv.classList.contains('hidden')) {
                    // Build a path identifier for this node
                    const label = item.querySelector('.tree-item-content .label');
                    if (label) {
                        const path = getNodePath(item);
                        expandedNodes.add(path);
                    }
                }
            });
        }

        function getNodePath(element) {
            const labels = [];
            let current = element;
            while (current) {
                if (current.classList && current.classList.contains('tree-item')) {
                    const label = current.querySelector(':scope > .tree-item-content .label');
                    if (label) {
                        labels.unshift(label.textContent);
                    }
                }
                current = current.parentElement;
            }
            return labels.join('/');
        }

        function restoreExpandedState() {
            const treeItems = document.querySelectorAll('.tree-item');
            treeItems.forEach(item => {
                const path = getNodePath(item);
                if (expandedNodes.has(path)) {
                    const childrenDiv = item.querySelector(':scope > .children');
                    const expandIcon = item.querySelector(':scope > .tree-item-content .expand-icon');
                    if (childrenDiv && childrenDiv.classList.contains('hidden')) {
                        childrenDiv.classList.remove('hidden');
                        if (expandIcon && expandIcon.classList.contains('codicon-chevron-right')) {
                            expandIcon.classList.remove('codicon-chevron-right');
                            expandIcon.classList.add('codicon-chevron-down');
                        }
                    }
                }
            });
        }

        function toggleNode(e, childrenDiv, icon) {
            // If the mouse moved more than 4px between mousedown and click it was a drag (text selection)
            const dx = e.clientX - mouseDownPos.x;
            const dy = e.clientY - mouseDownPos.y;
            if (Math.sqrt(dx * dx + dy * dy) > 4) {
                return;
            }

            // Clear any lingering text selection on a plain click
            if (window.getSelection) {
                window.getSelection().removeAllRanges();
            }
            childrenDiv.classList.toggle('hidden');
            if (childrenDiv.classList.contains('hidden')) {
                icon.className = 'expand-icon codicon codicon-chevron-right';
            } else {
                icon.className = 'expand-icon codicon codicon-chevron-down';
            }
        }

        function renderTree() {
            const container = document.getElementById('treeContainer');

            if (!schemaData || !schemaData.databases) {
                container.innerHTML = '<div class="no-data">No schema data loaded.</div>';
                return;
            }

            container.innerHTML = '';

            const filteredDatabases = schemaData.databases.filter(db =>
                !searchPattern || matchesSearch(db.name) ||
                db.tables.some(t => matchesSearch(t.name) ||
                    t.fields.some(f => matchesSearch(f.name) || matchesSearch(f.dataType)) ||
                    t.indexes.some(i => matchesSearch(i.name))
                )
            );

            if (filteredDatabases.length === 0) {
                container.innerHTML = '<div class="no-data">No matching items found.</div>';
                return;
            }

            filteredDatabases.forEach(db => {
                container.appendChild(createDatabaseNode(db));
            });
        }

        function createDatabaseNode(db) {
            const div = document.createElement('div');
            div.className = 'tree-item';

            // If the database name itself matches, show all tables unfiltered
            const dbNameMatches = searchPattern && matchesSearch(db.name);
            const filteredTables = dbNameMatches ? db.tables : db.tables.filter(t =>
                !searchPattern || matchesSearch(t.name) ||
                t.fields.some(f => matchesSearch(f.name) || matchesSearch(f.dataType)) ||
                t.indexes.some(i => matchesSearch(i.name))
            );

            // Auto-expand only when children matched (not when the db name itself matched)
            const dbExpanded = searchPattern && !dbNameMatches && filteredTables.length > 0;

            const content = document.createElement('div');
            content.className = 'tree-item-content';
            content.title = `${filteredTables.length} table${filteredTables.length !== 1 ? 's' : ''}`;
            content.innerHTML = `
                <span class="expand-icon codicon ${filteredTables.length > 0 ? (dbExpanded ? 'codicon-chevron-down' : 'codicon-chevron-right') : ''}"></span>
                <span class="icon codicon codicon-database"></span>
                <span class="label">${highlightText(db.name)}</span>
            `;

            div.appendChild(content);

            const childrenDiv = document.createElement('div');
            childrenDiv.className = dbExpanded ? 'children' : 'children hidden';

            filteredTables.forEach(table => {
                childrenDiv.appendChild(createTableNode(table, db.name));
            });

            div.appendChild(childrenDiv);

            content.addEventListener('click', (e) => {
                toggleNode(e, childrenDiv, content.querySelector('.expand-icon'));
            });

            return div;
        }

        function createTableNode(table, databaseName) {
            const div = document.createElement('div');
            div.className = 'tree-item';

            // If the table name itself matches, show all fields and indexes unfiltered
            const tableNameMatches = searchPattern && matchesSearch(table.name);
            const filteredFields = tableNameMatches ? table.fields : table.fields.filter(f =>
                !searchPattern || matchesSearch(f.name) || matchesSearch(f.dataType)
            );

            const filteredIndexes = tableNameMatches ? table.indexes : table.indexes.filter(i =>
                !searchPattern || matchesSearch(i.name)
            );

            // Auto-expand only when children matched (not when the table name itself matched)
            const tableExpanded = searchPattern && !tableNameMatches && (filteredFields.length > 0 || filteredIndexes.length > 0);

            const content = document.createElement('div');
            content.className = 'tree-item-content';
            content.title = `${filteredFields.length} field${filteredFields.length !== 1 ? 's' : ''}, ${filteredIndexes.length} index${filteredIndexes.length !== 1 ? 'es' : ''}`;
            content.innerHTML = `
                <span class="expand-icon codicon ${tableExpanded ? 'codicon-chevron-down' : 'codicon-chevron-right'}"></span>
                <span class="icon codicon codicon-table"></span>
                <span class="label">${highlightText(table.name)}</span>
            `;

            div.appendChild(content);

            const childrenDiv = document.createElement('div');
            childrenDiv.className = tableExpanded ? 'children' : 'children hidden';

            if (filteredFields.length > 0) {
                const fieldsContainer = createContainer('Fields', filteredFields, createFieldNode, databaseName, table.name);
                childrenDiv.appendChild(fieldsContainer);
            }

            if (filteredIndexes.length > 0) {
                const indexesContainer = createContainer('Indexes', filteredIndexes, createIndexNode);
                childrenDiv.appendChild(indexesContainer);
            }

            div.appendChild(childrenDiv);

            content.addEventListener('click', (e) => {
                toggleNode(e, childrenDiv, content.querySelector('.expand-icon'));
            });

            return div;
        }

        function createContainer(label, items, itemRenderer, databaseName, tableName) {
            const div = document.createElement('div');
            div.className = 'tree-item tree-item--container';

            const content = document.createElement('div');
            content.className = 'tree-item-content';
            content.innerHTML = `
                <span class="expand-icon codicon codicon-chevron-down"></span>
                <span class="icon codicon ${label === 'Fields' ? 'codicon-symbol-field' : 'codicon-key'}"></span>
                <span class="label">${label}</span>
            `;

            div.appendChild(content);

            const childrenDiv = document.createElement('div');
            childrenDiv.className = 'children';

            // Sort fields or indexes alphabetically if enabled
            let itemsToRender = items;
            if ((label === 'Fields' || label === 'Indexes') && sortAlphabetically) {
                itemsToRender = [...items].sort((a, b) => a.name.localeCompare(b.name));
            }

            itemsToRender.forEach(item => {
                childrenDiv.appendChild(itemRenderer(item));
            });

            div.appendChild(childrenDiv);

            content.addEventListener('click', (e) => {
                toggleNode(e, childrenDiv, content.querySelector('.expand-icon'));
            });

            return div;
        }

        function createFieldNode(field) {
            const div = document.createElement('div');
            div.className = 'tree-item';

            // Build description with dataType and extent
            let description = highlightText(field.dataType);
            if (field.extent && field.extent > 0) {
                description += ` [${field.extent}]`;
            }

            // Check if there are additional details to show
            const hasDetails = field.label || field.columnLabel || field.format || field.initial;

            const content = document.createElement('div');
            content.className = 'tree-item-content';
            content.innerHTML = `
                <span class="expand-icon codicon ${hasDetails ? 'codicon-chevron-right' : ''}"></span>
                <span class="label">${highlightText(field.name)}</span>
                <span class="description">${description}</span>
            `;

            div.appendChild(content);

            if (hasDetails) {
                const childrenDiv = document.createElement('div');
                childrenDiv.className = 'children hidden';

                if (field.label) {
                    childrenDiv.appendChild(createDetailNode('Label', field.label));
                }
                if (field.columnLabel) {
                    childrenDiv.appendChild(createDetailNode('Column Label', field.columnLabel));
                }
                if (field.format) {
                    childrenDiv.appendChild(createDetailNode('Format', field.format));
                }
                if (field.initial !== undefined && field.initial !== null) {
                    childrenDiv.appendChild(createDetailNode('Initial', field.initial));
                }

                div.appendChild(childrenDiv);

                content.addEventListener('click', (e) => {
                    toggleNode(e, childrenDiv, content.querySelector('.expand-icon'));
                });
            }

            return div;
        }

        function createIndexNode(index) {
            const div = document.createElement('div');
            div.className = 'tree-item';

            const indexType = index.primary ? 'Primary' : index.unique ? 'Unique' : 'Index';
            const hasFields = index.fields && index.fields.length > 0;

            const content = document.createElement('div');
            content.className = 'tree-item-content';
            content.innerHTML = `
                <span class="expand-icon codicon ${hasFields ? 'codicon-chevron-right' : ''}"></span>
                <span class="label">${highlightText(index.name)}</span>
                <span class="description">${indexType}</span>
            `;

            div.appendChild(content);

            if (hasFields) {
                const childrenDiv = document.createElement('div');
                childrenDiv.className = 'children hidden';

                index.fields.forEach((fieldName, idx) => {
                    childrenDiv.appendChild(createIndexFieldNode(fieldName, idx + 1));
                });

                div.appendChild(childrenDiv);

                content.addEventListener('click', (e) => {
                    toggleNode(e, childrenDiv, content.querySelector('.expand-icon'));
                });
            }

            return div;
        }

        function createIndexFieldNode(fieldName, position) {
            const div = document.createElement('div');
            div.className = 'tree-item';

            const content = document.createElement('div');
            content.className = 'tree-item-content';
            content.innerHTML = `
                <span class="expand-icon"></span>
                <span class="label">${escapeHtml(fieldName)}</span>
                <span class="description">Position ${position}</span>
            `;

            div.appendChild(content);
            return div;
        }

        function createDetailNode(label, value) {
            const div = document.createElement('div');
            div.className = 'tree-item';

            const content = document.createElement('div');
            content.className = 'tree-item-content';
            content.innerHTML = `
                <span class="expand-icon"></span>
                <span class="label">${escapeHtml(label)}</span>
                <span class="description">${escapeHtml(String(value))}</span>
            `;

            div.appendChild(content);
            return div;
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        function highlightText(text) {
            if (!searchPattern) return escapeHtml(text);

            let regexStr;
            if (useWildcard) {
                let pat = searchPattern;
                const specialChars = ['.', '+', '^', '$', '{', '}', '(', ')', '|', '[', ']', '\\'];
                specialChars.forEach(char => {
                    pat = pat.split(char).join('\\' + char);
                });
                regexStr = pat.replace(/\*/g, '.*').replace(/\?/g, '.');
            } else {
                regexStr = searchPattern.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
            }

            let regex;
            try {
                regex = new RegExp(regexStr, caseSensitive ? 'g' : 'gi');
            } catch {
                return escapeHtml(text);
            }

            const parts = [];
            let lastIndex = 0;
            let match;
            while ((match = regex.exec(text)) !== null) {
                if (match.index > lastIndex) {
                    parts.push(escapeHtml(text.slice(lastIndex, match.index)));
                }
                parts.push('<span class="search-highlight">' + escapeHtml(match[0]) + '</span>');
                lastIndex = match.index + match[0].length;
                if (match[0].length === 0) { regex.lastIndex++; }
            }
            if (lastIndex < text.length) {
                parts.push(escapeHtml(text.slice(lastIndex)));
            }
            return parts.join('');
        }

        function showLoading() {
            const container = document.getElementById('treeContainer');
            container.innerHTML = '<div class="loading">Loading schema...</div>';
        }
    </script>
</body>
</html>
